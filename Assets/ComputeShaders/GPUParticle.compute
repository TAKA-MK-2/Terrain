// 初期化
#pragma kernel Init
// エミット
#pragma kernel Emit
// 更新
#pragma kernel Update

// スレッド数
#define THREAD_NUM_X 32

// パーティクル情報
struct GPUParticleData
{
	// アクティブか判断する
	bool isActive;
	// 座標
	float3 position;
	// 速度
	float3 velocity;
	// スケール
	float scale;
	// 開始スケール
	float startScale;
	// 最終スケール
	float endScale;
	// 色
	float4 color;
	// 生存時間
	float lifeTime;
	// 経過時間
	float elapsedTime;
};

// floatの乱数生成(0～1)
inline float rnd(float2 p)
{
	return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// float3の乱数生成(-1～1)
inline float3 rnd3(float2 p) 
{
	return 2.0 * (float3(rnd(p * 1), rnd(p * 2), rnd(p * 3)) - 0.5);
}

// パーティクル情報
RWStructuredBuffer<GPUParticleData> _particles;
// 使用中のパーティクルの要素番号
AppendStructuredBuffer<uint> _activeList;
// 未使用のパーティクルの要素番号
AppendStructuredBuffer<uint> _deadList;
ConsumeStructuredBuffer<uint> _particlePool;

// 座標
float3 _position;
// スケール
float _scale;
// 経過時間
float _elapsedTime;
// エミッターのサイズ
float3 _range;
// エミットの方向
float3 _direction;
// 最低速度
float3 _minVelocity;
// 最高速度
float3 _maxVelocity;
// 重力
float _gravity;
// 角速度
float3 _angVelocity;
// 開始スケール
float _startScale;
// 最終スケール
float _endScale;
// 色情報
float3 _color;
// 生存時間
float _lifeTime;
// フレーム時間
float _deltaTime;

// 初期化処理
[numthreads(THREAD_NUM_X, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
	// 要素番号
	uint index = id.x;

	// 未使用リストに追加に追加
	_particles[index].isActive = false;
	_deadList.Append(index);
}

// エミット処理
[numthreads(THREAD_NUM_X, 1, 1)]
void Emit()
{
	// 要素番号をパーティクルプールから取り出す
	uint index = _particlePool.Consume();

	// 値をランダム化
	float2 seed = float2(index, index + 1) * _elapsedTime % 10000;
	float3 position = rnd3(seed);
	float3 velocity = rnd3(seed + 1);
	float startScale = rnd(seed + 2) * _startScale;
	float endScale = _endScale;

	// パーティクルを設定
	_particles[index].isActive = true;
	_particles[index].position = _position + (position * _range);
	_particles[index].velocity = (_maxVelocity - _minVelocity) * abs(velocity) + _minVelocity;
	_particles[index].startScale = startScale;
	_particles[index].endScale = endScale;
	_particles[index].color = float4(_color, 1);
	_particles[index].lifeTime = _lifeTime * rnd(seed + 3);
	_particles[index].elapsedTime = 0;
}

// 更新処理
[numthreads(THREAD_NUM_X, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
	// 要素番号
	uint index = id.x;

	// アクティブか判定
	if (_particles[index].isActive)
	{
		// パーティクルの更新処理
		_particles[index].position += _particles[index].velocity * _deltaTime;
		_particles[index].scale = (pow(_particles[index].elapsedTime / _particles[index].lifeTime, 3.0)) * (_particles[index].endScale - _particles[index].startScale) + _particles[index].startScale;
		_particles[index].velocity.y -= _gravity * _deltaTime;
		_particles[index].elapsedTime += _deltaTime;

		// 消滅時間になったか判定
		if (_particles[index].lifeTime < _particles[index].elapsedTime)
		{
			// パーティクルを非アクティブにする
			_particles[index].isActive = false;
			// 未使用リストに追加
			_deadList.Append(index);
		}
		else
		{
			// 使用中リストに追加
			_activeList.Append(index);
		}

	}

}
