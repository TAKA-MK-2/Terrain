// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update

#define THREAD_NUM_X 1024

struct ParticleData
{
	bool isActive;      // 有効フラグ
	float3 position;    // 座標
	float3 velocity;    // 加速度
	float4 color;       // 色
	float duration;     // 生存時間
	float scale;        // サイズ
};

// 乱数生成
inline float rnd(float2 p) {
	return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

inline float3 rnd3(float2 p) {
	return 2.0 * (float3(rnd(p * 1), rnd(p * 2), rnd(p * 3)) - 0.5);
}

float3 hsv_to_rgb(float3 HSV)
{
	float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(HSV.xxx + k.xyz) * 6.0 - k.www);
	return HSV.z * lerp(k.xxx, clamp(p - k.xxx, 0.0, 1.0), HSV.y);
}

RWStructuredBuffer<ParticleData> _particles;
AppendStructuredBuffer<uint> _deadList;
ConsumeStructuredBuffer<uint> _particlePool;
AppendStructuredBuffer<uint> _activeList;

float3 _emitPosition;
float _velocityMax;
float _deltaTime;
float _elapsedTime;
float _lifeTime;
float _scaleMin;
float _scaleMax;
float _gravity;
float _sai;
float _val;

[numthreads(THREAD_NUM_X, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
	uint no = id.x;

	_particles[no].isActive = false;
	_deadList.Append(no);
}

[numthreads(THREAD_NUM_X, 1, 1)]
void Emit()
{
	uint no = _particlePool.Consume();

	float2 seed = float2(no + _elapsedTime, no + 1.583 + _elapsedTime);
	float speed = rnd(seed) * _velocityMax;
	float scale = (rnd(seed + 3) - 0.5) * 2.0 * (_scaleMax - _scaleMin) + _scaleMin;
	float h = rnd(seed + 5);	// color

	_particles[no].isActive = true;
	_particles[no].position = _emitPosition;
	_particles[no].velocity = (rnd3(seed + 3.15)) * speed;
	_particles[no].color = float4(hsv_to_rgb(float3(h, _sai, _val)), 1);
	_particles[no].duration = _lifeTime;
	_particles[no].scale = scale;
}

[numthreads(THREAD_NUM_X, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
	uint no = id.x;

	if (_particles[no].isActive) {
		_particles[no].velocity.y -= _gravity * _deltaTime;
		_particles[no].position += _particles[no].velocity * _deltaTime;
		_particles[no].duration -= _deltaTime;
		_particles[no].color.a = max(_particles[no].duration / _lifeTime, 0);
		if (_particles[no].duration <= 0) {
			_particles[no].isActive = false;
			_deadList.Append(no);
		}
		else {
			_activeList.Append(no);
		}
	}

}
