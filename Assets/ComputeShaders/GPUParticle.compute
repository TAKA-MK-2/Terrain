#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update

#define THREAD_NUM_X 1

// パーティクル
struct GPUParticle
{
	// アクティブ状態
	bool isActive;
	// 座標
	float3 position;
	// 速度
	float3 velocity;
	// 回転
	float3 rotation;
	// 角速度
	float3 angVelocity;
	// 色
	float4 color;
	// スケール
	float scale;
	// 経過時間
	float elapsedTime;
	// 生存時間
	float lifeTime;
};

// パーティクルのバッファ
RWStructuredBuffer<GPUParticle> _particles;
// 未使用のパーティクルリストのバッファ
AppendStructuredBuffer<uint> _deadList;
// エミット時に取り出すパーティクルプールのバッファ
ConsumeStructuredBuffer<uint> _particlePool;
// デバッグ用バッファ
RWStructuredBuffer<uint> _debug;

// 1フレーム秒
float _deltaTime;
// スクリーンの幅
float _screenWidth;
// スクリーンの縦幅
float _screenHeight;
// パーティクルシステムの座標
float4 _position;
// エミット範囲
float4 _range;
// パーティクルの速度
float4 _velocity;
// パーティクルの角速度
float4 _angVelocity;
// パーティクルのスケール
float _scale;
// パーティクルの生存時間
float _lifeTime;
// ビュー射影行列
float4x4 _viewProj;
// 
Texture2D<float> _cameraDepthTexture;
// 
Texture2D<float4> _cameraGBufferTexture2;

// 
inline float GetDepth(float2 uv)
{
	float2 coord = float2(uv.x * _screenWidth, uv.y * _screenHeight);
	return _cameraDepthTexture[coord].r;
}

// 
inline float3 GetNormal(float2 uv)
{
	float2 coord = float2(uv.x * _screenWidth, uv.y * _screenHeight);
	return _cameraGBufferTexture2[coord].rgb * 2.0 - 1.0;
}

// 0～1のfloatの乱数を取得
inline float rand(float2 seed)
{
	return frac(sin(dot(seed.xy, float2(12.9898, 78.233))) * 43758.5453);
}

// 0～1のfloat3の乱数を取得
inline float3 rand3(float2 seed)
{
	return 2.0 * (float3(rand(seed * 1), rand(seed * 2), rand(seed * 3)) - 0.5);
}

// 初期化処理
[numthreads(1, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
	// スレッド番号
	uint index = id.x;
	// 非アクティブ状態にする
	_particles[index].isActive = false;
	// 未使用リストの末尾に追加
	_deadList.Append(index);
}

// エミット処理
[numthreads(1, 1, 1)]
void Emit()
{
	// 未使用リストの末尾からパーティクルの番号を取得
	uint index = _particlePool.Consume();
	// 乱数のシード値
	float2 seed = float2(index + 1, index + 2);
	// エミット位置
	float3 emitPosition = rand3(seed) * _range.xyz + _position;
	// パーティクルの速度
	float3 velocity = rand3(seed + 1) * _velocity.xyz;
	// パーティクルの回転
	float3 rotation = rand3(seed + 2) * _angVelocity.xyz;
	// パーティクルの設定
	GPUParticle p = _particles[index];
	p.isActive = true;
	p.position = emitPosition;
	p.velocity = velocity;
	p.rotation = rotation;
	p.angVelocity = p.rotation;
	p.color = 0;
	p.scale = 1.0;
	p.elapsedTime = 0.0;
	p.lifeTime = _lifeTime;
	_particles[index] = p;
}

// 更新処理
[numthreads(1, 1, 1)]
void Update(uint id : SV_DispatchThreadID)
{
	// パーティクルの番号
	uint index = id.x;
	// パーティクルを取り出す
	GPUParticle p = _particles[index];
	// パーティクルがアクティブ状態か判定
	if (p.isActive) 
	{
		// 経過時間を更新
		p.elapsedTime += _deltaTime;
		// 重力落下
		p.velocity.y += -9.8 * _deltaTime;
		// 縮小する
		p.scale = (1.0 - pow(p.elapsedTime / p.lifeTime, 3.0)) * _scale;
		// 回転処理
		p.rotation += p.angVelocity * _deltaTime;
		// 移動後座標
		float3 nextPos = p.position + p.velocity * _deltaTime;
		// 
		float4 vpPos = mul(_viewProj, float4(nextPos, 1.0));
		// 
		float2 uv = vpPos.xy / vpPos.w * 0.5 + 0.5;
		// 
		float gbufferDepth = GetDepth(uv);
		// 
		float particleDepth = vpPos.z / vpPos.w;
		// 
		float3 normal = GetNormal(uv);
		// パーティクルの深度とGBufferの深度で衝突判定
		if (particleDepth > gbufferDepth)
		{
			// めり込まないように速度を調整する
			p.velocity -= dot(p.velocity, normal) * normal * 1.99 /* 1.0 + bouciness */;
		}
		// 移動する
		p.position += p.velocity * _deltaTime;
		// 色を変更する
		p.color = float4(0, length(p.velocity) / 5, pow(p.elapsedTime / p.lifeTime, 2), 1);
		// 生存時間を過ぎたら消滅する
		if (p.elapsedTime > p.lifeTime)
		{
			// 非アクティブ状態にする
			p.isActive = false;
			// 未使用リストの末尾の追加する
			_deadList.Append(index);
		}
	}
	else 
	{
		// スケールを0にする
		p.scale = 0;
	}
	// 更新したパーティクルを設定する
	_particles[index] = p;
}