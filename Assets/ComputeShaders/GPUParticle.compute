// Each #kernel tells which function to compile; you can have many kernels
// 初期化
#pragma kernel Init
// エミット
#pragma kernel Emit
// 更新
#pragma kernel Update

#define THREAD_NUM_X 8

struct GPUParticleData
{
	// アクティブか判断する
	bool isActive;
	// 座標
	float3 position;
	// 速度
	float3 velocity;
	// 回転
	float3 rotation;
	// 角速度
	float3 angVelocity;
	// スケール
	float scale;
	// 開始スケール
	float startScale;
	// 最終スケール
	float endScale;
	// 生存時間
	float lifeTime;
	// 経過時間
	float elapsedTime;
};

// 乱数生成(0～1)
inline float rnd(float2 p)
{
	return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// (-1～1)
inline float3 rnd3(float2 p) 
{
	return 2.0 * (float3(rnd(p * 1), rnd(p * 2), rnd(p * 3)) - 0.5);
}

float3 hsv_to_rgb(float3 HSV)
{
	float4 k = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(HSV.xxx + k.xyz) * 6.0 - k.www);
	return HSV.z * lerp(k.xxx, clamp(p - k.xxx, 0.0, 1.0), HSV.y);
}

RWStructuredBuffer<GPUParticleData> _particles;
AppendStructuredBuffer<uint> _deadList;
ConsumeStructuredBuffer<uint> _particlePool;
AppendStructuredBuffer<uint> _activeList;

// 座標
float3 _position;
// スケール
float _scale;
// 経過時間
float _elapsedTime;
// エミッッターのサイズ
float3 _range;
// エミットの方向
float3 _direction;
// 速度
float3 _velocity;
// 重力
float _gravity;
// 角速度
float3 _angVelocity;
// 開始スケール
float _startScale;
// 最終スケール
float _endScale;
// 生存時間
float _lifeTime;
// 彩度
float _sai;
// 明るさ
float _val;
// フレーム時間
float _deltaTime;

[numthreads(THREAD_NUM_X, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
	uint no = id.x;

	_particles[no].isActive = false;
	_deadList.Append(no);
}

[numthreads(THREAD_NUM_X, 1, 1)]
void Emit()
{
	uint no = _particlePool.Consume();
	float2 seed = float2(no + _elapsedTime, no + 1 + _elapsedTime);
	float3 position = rnd3(seed);
	float3 rotation = rnd3(seed + 1);
	float3 velocity = rnd3(seed + 2);
	float startScale = rnd(seed + 3) * _startScale;
	float endScale = rnd(seed + 4) * (_endScale - _startScale) + _startScale;

	_particles[no].isActive = true;
	_particles[no].position = _position + (position * _range);
	_particles[no].velocity = _velocity * velocity;
	_particles[no].rotation = _angVelocity * rotation;
	_particles[no].angVelocity = _angVelocity * rotation;
	_particles[no].startScale = startScale;
	_particles[no].endScale = endScale;
	_particles[no].lifeTime = _lifeTime * rnd(seed + 3);
	_particles[no].elapsedTime = 0;
}

[numthreads(THREAD_NUM_X, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
	uint no = id.x;

	_particles[no].elapsedTime += _deltaTime;
	if (_particles[no].lifeTime <= _particles[no].elapsedTime)
	{
		_particles[no].isActive = false;
		_deadList.Append(no);
	}
	else
	{
		_activeList.Append(no);
	}

	if (_particles[no].isActive)
	{
		_particles[no].position += _particles[no].velocity * _deltaTime;
		_particles[no].velocity.y -= _gravity * _deltaTime;
		_particles[no].rotation += _particles[no].angVelocity * _deltaTime;
		_particles[no].scale = (_particles[no].endScale - _particles[no].startScale) * (1 - pow(_particles[no].elapsedTime / _particles[no].lifeTime, 3.0)) + _particles[no].startScale;
	}

}
